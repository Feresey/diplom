 Рассмотрев возможность автоматической генерации данных, я пришел к выводу, что в общем случае невозможно создать абсолютно корректные искусственные данные. Это связано с тем, что клиентское приложение, которое работает с базой данных, контролирует добавление данных. Следовательно, для автоматической генерации искусственных данных необходимо разработать специальное приложение, которое содержит всю необходимую логику работы с базой, подобную той, которая есть в клиентском приложении.
	Однако, если отбросить идею создания абсолютно корректных данных, можно ограничиться созданием SQL-скриптов. Такие скрипты будут содержать предположительно верные команды для добавления данных. Этот метод значительно упростит создание искусственно заполненной базы и не ограничит разработчика в  изменении предложенных данных.
	Если использовать такой подход, то он неплохо соотносится с моим предложением об использовании скриптов для заполнения базы. Хотя в таком случае возможно добавление изначально некорректных данных, но подобную ошибку может обнаружить только человек, который имеет доступ к структуре базы и представление о том, как клиентское приложение должно с ней взаимодействовать. В таком случае только ручная валидация данных может обнаружить некорректные данные, которые не предусмотрены логикой приложения.
	Касательно Ваших слов «Но мы знаем, что будет изменено, и будем действовать целенаправленно.». Я не исследую сам скрипт миграции, потому что он может содержать любые команды, которые весьма проблематично обработать автоматически.
	Я основываю свою идею проверки миграций на концепции черного ящика: даже без конкретной информации о предстоящих изменениях можно предположить, какие из этих изменений могут вызвать ошибку. Например, добавление UNIQUE или NOT NULL ограничений без предварительной проверки может вызвать ошибку. Либо изменение типа колонки с TEXT на VARCHAR(255) без проверки на максимальный размер уже находящихся в таблице записей.
	Не знаю как лучше обосновать то, что таблицы должны быть заполнены данными.
                          Вставка  генерируемых данных
	Существующие связи между таблицами не позволяют заполнять их в произвольном порядке, так как индексы гарантируют, что в базе не существует связей,  которые ссылаются на ещё не добавленные данные. В общем виде связи между таблицами представляют собой направленный мультиграф с одной или несколькими компонентами связности, где направление обозначает связь между родительской и дочерней таблицей. То есть при заполнении таблиц нужно учитывать множественные связи между таблицами и циклически связанные таблицы.
                       Циклически связанные таблицы
	Важно отметить, что циклически связанные таблицы со связями 1:N являются особенными. В случае если все таблицы цикла являются пустыми, то вставка данных невозможна. Работа с циклически связанными таблицами затруднительна и скорее всего является ошибкой проектирования.
	Для демонстрации возможности создания циклически связанных таблиц со связями 1:N, можно рассмотреть следующий SQL-код:

CREATE TABLE a(id INTEGER PRIMARY KEY);
CREATE TABLE b(id INTEGER PRIMARY KEY);

INSERT INTO b (id) VALUES (1);
INSERT INTO a (id) VALUES (1);

ALTER TABLE a ADD COLUMN val_a INTEGER NOT NULL REFERENCES b(id) DEFAULT 1;
ALTER TABLE b ADD COLUMN val_b INTEGER NOT NULL REFERENCES a(id) DEFAULT 1;

	Даже если в цикле есть хотя бы одна связь 0-1:N, где внешний ключ может быть NULL, использование цикла все равно весьма сомнительно.	
	Таким образом я пришел к выводу что не нужно генерировать данные для циклически связанных таблиц — для взаимодействия с каждым циклом нужна своя уникальная логика.
                       Заполнение без учета циклов
	Если удалить все циклы из графа связей таблиц, то можно определить порядок обхода вершин. Данный алгоритм обхода похож на поиск в глубину, за исключением того, что на каждой итерации выбирается не всегда смежная вершина. На каждой итерации алгоритма выбирается вершина, которая не имеет зависимостей от ещё не пройденных вершин. Таким образом, можно определить порядок заполнения таблиц при условии отсутствия циклических связей между таблицами в базе.


 а вершина, не имеющая зависимостей от 

На каждой итерации алгоритма будет закрашиваться одна вершина, которая не была закрашена ранее и которая не имеет зависимостей от ещё не закрашенных вершин
И в такой структуре можно определить порядок обхода вершин графа. На каждой итерации находится вершина, которая не является дочерней для другой непройденной вершины. 


Такое определение весьма близко к определению дерева, с той лишь разницей, что у такого «дерева» между родительской и дочерней таблицей может быть более одной связи.
	В случае дерева очевидны алгоритмы поиска корневой вершины и обхода узлов дерева.


Проблема: связь многие ко многим из разных компонент связности. Связующая таблица в таком случае представляет из себя вершину. А со стороны одной из компонент получится, что у какого-то узла существует связь «вверх», на промежуточную вершину. Я хз чо с этим делать

 Поддеревья в рамках одной компоненты связности!
 То есть внутри одной компоненты есть несколько вершин деревьев. И у некоторых из этих деревьев могут быть общие листья. Только листья? Нет, общие узлы тоже возможны. Тогда надо отойти от идеи дерева и называть это просто порядком обхода. А как обходить? Да тупо перебором. На каждом этапе ищется таблица, у которой нет зависимостей от ещё не заполненных таблиц. Если такая таблица не найдена — цикл. Если цикл, то он минимизируется и вырезается. Правильно ли это?
