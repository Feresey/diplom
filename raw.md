	Рассмотрев возможность автоматической генерации данных, я пришел к выводу, что в общем случае невозможно создать абсолютно корректные искусственные данные. Это связано с тем, что клиентское приложение, которое работает с базой данных, контролирует добавление данных. Следовательно, для автоматической генерации искусственных данных необходимо разработать специальное приложение, которое содержит всю необходимую логику работы с базой, подобную той, которая есть в клиентском приложении.
	Однако, если отбросить идею создания абсолютно корректных данных, можно ограничиться созданием SQL-скриптов. Такие скрипты будут содержать предположительно верные команды для добавления данных. Этот метод значительно упростит создание искусственно заполненной базы и не ограничит разработчика в  изменении предложенных данных.
	Если использовать такой подход, то он неплохо соотносится с моим предложением об использовании скриптов для заполнения базы. Хотя в таком случае возможно добавление некорректных данных, но подобную ошибку может обнаружить только человек, который имеет доступ к структуре базы и представление о том, как клиентское приложение должно с ней взаимодействовать. В таком случае только ручная валидация данных может обнаружить некорректные данные, которые не предусмотрены логикой приложения.

Касательно ваших слов «Но мы знаем, что будет изменено, и будем действовать целенаправленно.»: сомневаюсь что возможно отследить все изменения, ведь у меня есть только 2 состояния базы — до и после миграции. Сам скрипт для меня — черный ящик, внутри него может происходить все что угодно. Так же я думаю что отслеживать 

 не отслеживать атомарные изменения в миграциях, ведь для миграции данных могут создаваться временные таблицы, применяться абсолютно любые команды для добавления, получения, изменения или удаления данных. Я стараюсь дистанцироваться от таких проверок, потому что невозможно в общем случае предусмотреть и проверить всю логику, заложенную в скрипт. Только в том случае если сама миграция является атомарным действием можно однозначно определить что именно изменилось после применения миграции. Я даже видел несколько открытых проектов, которые практикуют атомарные миграции, например в одном из таких проектов насчитывается более тысячи файлов миграций (хотя по факту не все из них являются атомарными действиями, но разработчики стремятся минимизировать объём каждой из миграций) 

но с возможностью ручного изменения этих скриптов. 

Я думал о возможности генерации данных и пришёл к выводу что невозможно сгенерировать абсолютно корректные данные в общем случае, потому что добавление данных в базу регулирует только приложение, для которого эта база была подготовлена.  Если говорить об автоматической генерации, то приложение для автоматической генерации должно включать в себя всю ту логику работы с базой, которая есть в клиентском приложении.

 Если говорить именно об автоматической генерации, то чтобы сгенерировать абсолютно корректные данные
В рамках одной таблицы , то чтобы покрыть как можно большее количество возможных изменений структуры

Сгенерировать всегда корректные данные весьма проблематично, потому что я по могу предположить какие запросы должны добавлять данные, ведь добавлением данных в рассматриваемом случае занимается только приложение. Действительно, некоторые проблемы по типу связанных таблиц относительно легко решаются построением графа связей, но все равно остаются способы добавления и валидации данных, которые не так просто предусмотреть. Например триггеры — каждый триггер это отдельный скрипт, который должен вызываться для определенного действия. Я не считаю возможным предугадать состояние базы, ожидаемое триггером при его вызове. Проще говоря я не могу предусмотреть такое динамическое изменение логики взаимодействия данных. Даже если считать что динамического арбитража в базе нет, статический арбитраж тоже может набросить на вентилятор. Достаточно одного условия CHECK, которое будет ограничивать множество возможных значений для колонки, или ещё хуже — целой строки. Безусловно, можно попытаться выявить подмножество возможных значений, но это скорее тема для отдельного диплома